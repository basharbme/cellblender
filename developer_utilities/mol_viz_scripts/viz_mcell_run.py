#############################################################################################
#
# Terminal input: blender -P ~/.../cellblender/developer_utilities/mol_viz_scripts/dat_to_blender.py -- ~/.../viz_data/seed_00001 <-- where the .dat or .ascii files are located.
# 
# This file reads binary data files that are generated by MCell and updates their display in blender. 
# Color and object geomerty are not handled here (because this data is not given in the seed_00001 files).
#
#############################################################################################

import json
import bpy
import os
import re
import sys

#FIXME: need to find cellblender plugin directory, maybe pass as argument
THIS_DIR = os.path.dirname(os.path.realpath(__file__))
CELLBLENDER_DIR = os.path.join(THIS_DIR, '..', '..')
if not os.path.exists(CELLBLENDER_DIR):
    print("Directory where the cellblender plugin should reside was not found: " + CELLBLENDER_DIR)
    sys.exit(1)
sys.path.insert(1, CELLBLENDER_DIR)
import cellblender_mol_viz as cb_mv
import data_model


# TODO: better argument checking 
INPUT_DIRECTORY_ARG = sys.argv[4]

if len(sys.argv) == 6:
    DATA_MODEL_FILE_ARG = sys.argv[5]
else:
    DATA_MODEL_FILE_ARG = None

g_last_data_model_loaded = ""
g_last_viz_file_loaded = ""

# this is a dictionary that maps frame index onto a pair (viz file, data model file)
g_frame_to_files = {}


def mol_viz_update_from_file(mcell, filename):
    """ Clear the old viz data. Draw the new viz data. """

    mcell.mol_viz.mol_file_name = filename
    filepath = os.path.join(mcell.mol_viz.mol_file_dir, filename)

    # Save current global_undo setting. Turn undo off to save memory
    global_undo = bpy.context.user_preferences.edit.use_global_undo
    bpy.context.user_preferences.edit.use_global_undo = False

    cb_mv.mol_viz_clear(mcell)
    cb_mv.mol_viz_file_read(mcell, filepath)

    # Reset undo back to its original state
    bpy.context.user_preferences.edit.use_global_undo = global_undo    


def update_frame_data(scene):
    # this is our iteration
    frame_index = bpy.context.scene.frame_current - 1
    
    if frame_index not in g_frame_to_files:
        print('Warning: data for frame number '+ str(bpy.context.scene.frame_current) + ' were not found.')
        return
        
    viz, dm = g_frame_to_files[frame_index]
    
    # data model does not have to be present
    if dm != "" and dm != g_last_data_model_loaded:
        data_model.import_datamodel_all_json(dm, bpy.context)
        global g_last_data_model_loaded
        g_last_data_model_loaded = dm
    
    # molecule positions must be found        
    if viz != g_last_viz_file_loaded:
        # file.path gets the entire folder path as well as the file name as a string.
        mol_viz_update_from_file(bpy.context.scene.mcell, viz)
        global g_last_viz_file_loaded
        g_last_viz_file_loaded = viz

    
def get_corresponding_dm_file(dm_files, iteration):
    best_match = ""
    for k, v in sorted(dm_files.items()):
        if k <= iteration:
            best_match = v
    return best_match
    

def init_frame_files_mapping():
    
    # get nr of frames
    max_frame_nr = -1
    filepath = os.scandir(INPUT_DIRECTORY_ARG)
    viz_files = []
    dm_files = {}
    for file in filepath:
        # --- viz data ---
        if re.match(r'(.*\.[0-9]+\.dat)', str(file)):
            name = str(file.path)
            iteration = int(name.split('.')[-2])
            viz_files.append(name)
            
            
        if not DATA_MODEL_FILE_ARG:
            if re.match(r'(.*\.data_model\.[0-9]+\.json)'.format(), str(file)):
                name = str(file.path)
                iteration = int(name.split('.')[-2])
                dm_files[iteration] = name

    # if passed by argument, this is our only data model file
    if DATA_MODEL_FILE_ARG:
        dm_files[0] = DATA_MODEL_FILE_ARG


    # viz files must be sorted by iteration
    viz_files.sort()

    # the sorted viz files determine the frame, 
    # data model files follow the ordering, 
    # 
    global g_frame_to_files
    for i in range(0, len(viz_files)):
        dm = get_corresponding_dm_file(dm_files, i)
        g_frame_to_files[i] = (viz_files[i], dm)
                
    bpy.context.scene.frame_end = len(g_frame_to_files)
    

print("*** Loading visualization data from directory " + INPUT_DIRECTORY_ARG)
if not os.path.exists(INPUT_DIRECTORY_ARG):
    print("Error: directory " + INPUT_DIRECTORY_ARG + " does not exist, terminating.")
    sys.exit(1)

# remove all default objects from blender startup
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete()

# set number of frames and 
init_frame_files_mapping()

# load first file
update_frame_data(bpy.context.scene)

# register a handler for events when frame changes
# update the visual output by sending the .dat files created by mcell into cellblender for each frame
bpy.app.handlers.frame_change_pre.append(update_frame_data)
