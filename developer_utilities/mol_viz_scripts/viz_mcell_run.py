#############################################################################################
#
# Terminal input: blender -P ~/.../cellblender/developer_utilities/mol_viz_scripts/dat_to_blender.py -- ~/.../viz_data/seed_00001 <-- where the .dat or .ascii files are located.
# 
# This file reads binary data files that are generated by MCell and updates their display in blender. 
# Color and object geomerty are not handled here (because this data is not given in the seed_00001 files).
#
#############################################################################################

import json
import bpy
import os
import re
import sys

#FIXME: need to find cellblender plugin directory, maybe pass as argument
THIS_DIR = os.path.dirname(os.path.realpath(__file__))
CELLBLENDER_DIR = os.path.join(THIS_DIR, '..', '..')
if not os.path.exists(CELLBLENDER_DIR):
    print("Directory where the cellblender plugin should reside was not found: " + CELLBLENDER_DIR)
    sys.exit(1)
sys.path.insert(1, CELLBLENDER_DIR)
import cellblender_mol_viz as cb_mv
import data_model


# TODO: better argument checking 
INPUT_DIRECTORY_ARG = sys.argv[4]

if len(sys.argv) == 6:
    DATA_MODEL_FILE_ARG = sys.argv[5]
else:
    DATA_MODEL_FILE_ARG = None

g_last_data_model_loaded = ""
g_last_viz_file_loaded = ""
g_last_obj_file_loaded = ""

# this is a dictionary that maps frame index onto a pair (viz file, data model file)
g_frame_to_files = {}


def mol_viz_update_from_file(mcell, filename):
    """ Clear the old viz data. Draw the new viz data. """

    mcell.mol_viz.mol_file_name = filename
    filepath = os.path.join(mcell.mol_viz.mol_file_dir, filename)

    # Save current global_undo setting. Turn undo off to save memory
    global_undo = bpy.context.user_preferences.edit.use_global_undo
    bpy.context.user_preferences.edit.use_global_undo = False

    cb_mv.mol_viz_clear(mcell)
    cb_mv.mol_viz_file_read(mcell, filepath)

    # Reset undo back to its original state
    bpy.context.user_preferences.edit.use_global_undo = global_undo    


def update_frame_data(scene):
    # this is our iteration
    frame_index = bpy.context.scene.frame_current - 1
    
    if frame_index not in g_frame_to_files:
        print('Warning: data for frame number '+ str(bpy.context.scene.frame_current) + ' were not found.')
        return
        
    viz, dm, obj = g_frame_to_files[frame_index]
    
    # data model does not have to be present
    if dm != "" and dm != g_last_data_model_loaded:
        data_model.import_datamodel_all_json(dm, bpy.context)
        global g_last_data_model_loaded
        g_last_data_model_loaded = dm
        
    # obj file does not have to be present, it overrides geometry that coudl be loaded 
    # through data model 
    if obj != "" and obj != g_last_obj_file_loaded:
        # delete all objects not used to visualize molecules
        bpy.ops.object.select_all(action='DESELECT')
        deleted_obj_names = []
        for scene_object in bpy.context.scene.objects:
            # we must not remove molecule shapes
            if scene_object.type == 'MESH' and \
                not (scene_object.name == 'molecules' or \
                     scene_object.name.startswith('mol_')):
                #print ( "Deleting Mesh object: " + scene_object.name )
                scene_object.hide = False
                scene_object.select = True
                # rename so that the newly imported objects gen new name 
                deleted_obj_names.append(scene_object.name)
                scene_object.name = scene_object.name + '_old'
                scene_object.data.name = scene_object.name + '_old'
                bpy.ops.object.delete()
               
        # TODO: remove unused materials here, not sure how to do it  
            
        # load object file
        ret = bpy.ops.import_scene.obj(filepath=obj)
        obj_objects = bpy.context.selected_objects[:]
        
        # set all objects as transparent
        for obj in obj_objects:
            obj.show_transparent = True
            
        bpy.ops.object.select_all(action='DESELECT')
        
        global g_last_obj_file_loaded
        g_last_obj_file_loaded = obj
    
    # molecule positions must be found        
    if viz != g_last_viz_file_loaded:
        # file.path gets the entire folder path as well as the file name as a string.
        mol_viz_update_from_file(bpy.context.scene.mcell, viz)
        global g_last_viz_file_loaded
        g_last_viz_file_loaded = viz

    
def get_corresponding_file(dm_files, iteration):
    best_match = ""
    for k, v in sorted(dm_files.items()):
        if k <= iteration:
            best_match = v
    return best_match


def init_frame_files_mapping():
    
    # get nr of frames
    max_frame_nr = -1
    filepath = os.scandir(INPUT_DIRECTORY_ARG)
    viz_files = []
    obj_files = {}
    dm_files = {}
    for file in filepath:
        # --- viz data ---
        if re.match(r'(.*\.[0-9]+\.dat)', str(file)):
            name = str(file.path)
            iteration = int(name.split('.')[-2])
            viz_files.append(name)

        elif re.match(r'(.*\.[0-9]+\.obj)', str(file)):
            name = str(file.path)
            iteration = int(name.split('.')[-2])
            obj_files[iteration] = name
            
        elif not DATA_MODEL_FILE_ARG:
            if re.match(r'(.*\.data_model\.[0-9]+\.json)'.format(), str(file)):
                name = str(file.path)
                iteration = int(name.split('.')[-2])
                dm_files[iteration] = name

    # if passed by argument, this is our only data model file
    if DATA_MODEL_FILE_ARG:
        dm_files[0] = DATA_MODEL_FILE_ARG


    # viz files must be sorted by iteration
    viz_files.sort()

    # the sorted viz files determine the frame, 
    # data model files follow the ordering, 
    # 
    global g_frame_to_files
    for i in range(0, len(viz_files)):
        dm = get_corresponding_file(dm_files, i)
        obj = get_corresponding_file(obj_files, i)
        g_frame_to_files[i] = (viz_files[i], dm, obj)
                
    bpy.context.scene.frame_end = len(g_frame_to_files)
    

print("*** Loading visualization data from directory " + INPUT_DIRECTORY_ARG)
if not os.path.exists(INPUT_DIRECTORY_ARG):
    print("Error: directory " + INPUT_DIRECTORY_ARG + " does not exist, terminating.")
    sys.exit(1)

# remove all default objects from blender startup
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete()

# set number of frames and 
init_frame_files_mapping()

# load first file
update_frame_data(bpy.context.scene)

# register a handler for events when frame changes
# update the visual output by sending the .dat files created by mcell into cellblender for each frame
bpy.app.handlers.frame_change_pre.append(update_frame_data)
